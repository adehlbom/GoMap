package main

import (
	"fmt"
	"net"
	"strings"
	"time"
)

// VulnerabilityInfo represents a potential security issue
type VulnerabilityInfo struct {
	Type        string  // e.g., "Open Service", "Weak Configuration", "Known CVE"
	Description string  // A description of the vulnerability
	Severity    string  // "Low", "Medium", "High", "Critical"
	Confidence  float64 // 0.0 to 1.0, how confident we are in this finding
}

// ScanForVulnerabilities performs a vulnerability scan on a given host
func ScanForVulnerabilities(ip string, openPorts []int) []VulnerabilityInfo {
	var vulnerabilities []VulnerabilityInfo

	// Check for commonly exploitable services
	for _, port := range openPorts {
		// Get more detailed service information with banner grabbing
		service, banner := grabServiceBanner(ip, port)

		// Check for specific vulnerabilities based on port and banner
		switch port {
		case 21: // FTP
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Open Service",
				Description: "FTP service (port 21) - Data transmitted in cleartext",
				Severity:    "Medium",
				Confidence:  0.9,
			})

			// Check for anonymous FTP access
			if strings.Contains(strings.ToLower(banner), "anonymous") {
				vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
					Type:        "Weak Configuration",
					Description: "FTP service may allow anonymous access",
					Severity:    "High",
					Confidence:  0.7,
				})
			}

		case 22: // SSH
			// Check for SSH version in banner
			if strings.Contains(strings.ToLower(banner), "ssh-1") {
				vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
					Type:        "Outdated Service",
					Description: "SSH service running outdated protocol (SSHv1)",
					Severity:    "High",
					Confidence:  0.8,
				})
			}

		case 23: // Telnet
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Insecure Protocol",
				Description: "Telnet service (port 23) - Transmits credentials in cleartext",
				Severity:    "Critical",
				Confidence:  0.95,
			})

		case 25, 587: // SMTP
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Configuration Check",
				Description: "SMTP service - Check for open relay",
				Severity:    "Medium",
				Confidence:  0.6,
			})

		case 53: // DNS
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Configuration Check",
				Description: "DNS service - Check for zone transfers and DNS amplification",
				Severity:    "Medium",
				Confidence:  0.7,
			})

		case 80, 8080: // HTTP
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Information",
				Description: "HTTP service without encryption - Consider using HTTPS",
				Severity:    "Low",
				Confidence:  0.8,
			})

			// Check for specific web servers with known vulnerabilities
			if strings.Contains(strings.ToLower(banner), "apache/2.4") {
				if strings.Contains(strings.ToLower(banner), "apache/2.4.49") ||
					strings.Contains(strings.ToLower(banner), "apache/2.4.50") {
					vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
						Type:        "Known CVE",
						Description: "Apache 2.4.49/2.4.50 - Path Traversal Vulnerability (CVE-2021-41773, CVE-2021-42013)",
						Severity:    "Critical",
						Confidence:  0.9,
					})
				}
			}

		case 139, 445: // SMB/NetBIOS
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Configuration Check",
				Description: "SMB service - Check for EternalBlue vulnerability and weak share permissions",
				Severity:    "High",
				Confidence:  0.7,
			})

		case 1433: // MS-SQL
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Database Service",
				Description: "Microsoft SQL Server - Ensure strong authentication and TCP endpoint filtering",
				Severity:    "Medium",
				Confidence:  0.8,
			})

		case 3306: // MySQL
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Database Service",
				Description: "MySQL Database - Ensure strong password and restricted access",
				Severity:    "Medium",
				Confidence:  0.8,
			})

		case 3389: // RDP
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Remote Access",
				Description: "RDP service - Potential entry point for brute force attacks",
				Severity:    "Medium",
				Confidence:  0.8,
			})

			// Check for BlueKeep vulnerability (approximate)
			if banner == "" { // RDP typically doesn't return a banner on plain connect
				vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
					Type:        "Configuration Check",
					Description: "RDP service - Check for BlueKeep vulnerability (CVE-2019-0708)",
					Severity:    "Critical",
					Confidence:  0.5, // We're not actually checking, just suggesting
				})
			}
		}

		// Add generic info for uncommon open ports
		if service == "" && port > 1024 && port != 3306 && port != 3389 {
			vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
				Type:        "Unknown Service",
				Description: fmt.Sprintf("Uncommon port %d open with unknown service", port),
				Severity:    "Low",
				Confidence:  0.4,
			})
		}
	}

	// Check for too many open ports
	if len(openPorts) > 15 {
		vulnerabilities = append(vulnerabilities, VulnerabilityInfo{
			Type:        "Configuration",
			Description: fmt.Sprintf("High number of open ports (%d) - Consider closing unnecessary services", len(openPorts)),
			Severity:    "Medium",
			Confidence:  0.7,
		})
	}

	return vulnerabilities
}

// grabServiceBanner attempts to grab a service banner from the specified port
func grabServiceBanner(ip string, port int) (service string, banner string) {
	service = getServiceNameByPort(port)

	// Skip banner grabbing for certain services that might hang
	if port == 53 || port == 161 || port == 162 {
		return service, ""
	}

	// Try to connect and grab a banner
	address := fmt.Sprintf("%s:%d", ip, port)
	conn, err := net.DialTimeout("tcp", address, 2*time.Second)
	if err != nil {
		return service, ""
	}
	defer conn.Close()

	// Set a read deadline so we don't wait too long
	conn.SetReadDeadline(time.Now().Add(3 * time.Second))

	// Read the banner
	buffer := make([]byte, 1024)
	n, err := conn.Read(buffer)
	if err != nil {
		return service, ""
	}

	// Clean the banner
	banner = cleanBanner(string(buffer[:n]))
	return service, banner
}
